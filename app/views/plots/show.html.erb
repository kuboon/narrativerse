<main class="page">
  <section class="detail">
    <div class="detail-header">
      <h1><%= @plot.title %></h1>
      <div class="detail-actions">
        <% if @story_links.any? %>
          <%= link_to "読む", reader_path(@plot), class: "btn primary" %>
        <% end %>
        <%# Story-add button removed per new flow (manage via plots#show content) %>
        <% if policy(@plot).update? %>
          <%= link_to "編集", edit_plot_path(@plot), class: "btn ghost" %>
        <% end %>
      </div>
    </div>
    <p><%= @plot.summary.presence || "まだ概要がありません。" %></p>

    <div class="detail-meta">
      <div>
        <span class="meta-label">作成者</span>
        <span><%= @plot.user.name %></span>
      </div>
      <div>
        <span class="meta-label">親プロット</span>
        <span><%= @plot.parent_plots.map(&:title).join(", ").presence || "なし" %></span>
      </div>
    </div>
    <% if policy(@plot).manage_elements? %>
      <div class="detail-actions">
        <%= link_to "要素を追加", new_plot_plot_element_path(@plot), class: "btn ghost" %>
      </div>
    <% end %>

    <% if @plot.plot_elements.any? %>
      <div class="grid">
        <div class="grid-header">
          <h2>登場要素</h2>
        </div>
        <div class="cards">
          <% @plot.plot_elements.includes(:element, :element_revision).each do |plot_element| %>
            <article class="card">
              <h3><%= plot_element.element.name %></h3>
              <p class="badge"><%= t("elements.types.#{plot_element.element.element_type.downcase}") %></p>
              <p><%= plot_element.summary.presence || plot_element.element_revision&.summary.presence || "まだ概要がありません。" %></p>
              <div class="card-actions">
                <%= link_to "詳細", element_path(plot_element.element), class: "text-link" %>
                <% if policy(@plot).manage_elements? %>
                  <%= link_to "編集", edit_plot_plot_element_path(@plot, plot_element), class: "text-link" %>
                  <% if plot_element.element.latest_revision && plot_element.element.latest_revision.id != plot_element.element_revision_id %>
                    <%= button_to "更新する", refresh_revision_plot_plot_element_path(@plot, plot_element), method: :patch, class: "btn ghost" %>
                  <% end %>
                  <%= button_to "削除", plot_plot_element_path(@plot, plot_element), method: :delete, class: "btn ghost" %>
                <% end %>
              </div>
            </article>
          <% end %>
        </div>
      </div>
    <% end %>

    <% if @story_links.any? %>
      <div class="grid">
        <div class="story-flow" id="story-flow">
          <% @story_links.each do |link| %>
            <%= render "scenes/panel", link: %>
          <% end %>
        </div>
        <% if policy(@plot).manage_story? %>
          <div class="actions mt-4">
            <%= button_to "シーンを追加", plot_plot_scene_links_path(@plot, scene: { text: "新しいシーン" }), method: :post, form: { data: { turbo: true } }, class: "btn primary w-full text-center" %>
          </div>
        <% end %>
      </div>
    <% end %>

  </section>
</main>

<script>
  (function() {
    let currentEditor = null;

    const startEditing = (container) => {
      if (currentEditor && currentEditor !== container) {
        stopEditing(currentEditor);
      }
      currentEditor = container;
      const editor = container.querySelector(".scene-editor");
      if (!editor) return; // non-owners have no editor — do nothing
      container.querySelector(".scene-display").classList.add("hidden");
      editor.classList.remove("hidden");
      const textarea = editor.querySelector("textarea");
      textarea.focus();
      // Adjust height
      textarea.style.height = 'auto';
      textarea.style.height = textarea.scrollHeight + 'px';
    };

    const submitFormWithFetch = async (form) => {
      const action = form.action;
      const method = (form.method || 'post').toUpperCase();

      const tokenMeta = document.querySelector('meta[name="csrf-token"]');
      const csrfToken = tokenMeta ? tokenMeta.content : null;

      const formData = new FormData(form);
      const body = new URLSearchParams();
      for (const pair of formData.entries()) { body.append(pair[0], pair[1]); }

      const resp = await fetch(action, {
        method: method === 'POST' ? 'POST' : method,
        credentials: 'same-origin',
        headers: Object.assign({ 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8' }, csrfToken ? { 'X-CSRF-Token': csrfToken } : {}),
        body: body.toString()
      });

      const contentType = resp.headers.get('content-type') || '';
      const text = await resp.text();

      if (contentType.includes('text/vnd.turbo-stream')) {
        if (window.Turbo && typeof Turbo.renderStreamMessage === 'function') {
          Turbo.renderStreamMessage(text);
        } else {
          // Fallback: replace container with returned HTML
          const parser = new DOMParser();
          const doc = parser.parseFromString(text, 'text/html');
          const replacement = doc.body.firstElementChild;
          const id = replacement && replacement.id;
          if (id) {
            const old = document.getElementById(id);
            if (old && replacement) old.replaceWith(replacement);
          }
        }
      } else if (resp.redirected) {
        window.location = resp.url;
      }
    };

    const stopEditing = (container) => {
      if (!container) return;
      const form = container.querySelector("form");
      if (form) submitFormWithFetch(form).catch(err => { console.error(err); form.requestSubmit(); });
      currentEditor = null;
    };

    document.addEventListener("click", (e) => {
      const display = e.target.closest(".scene-display");
      if (display) {
        const container = display.closest(".scene-container");
        if (container) startEditing(container);
      }
    });

    document.addEventListener("focusout", (e) => {
      if (currentEditor && currentEditor.contains(e.target)) {
        // Check if new focus is still within the editor
        setTimeout(() => {
          if (!currentEditor.contains(document.activeElement)) {
            stopEditing(currentEditor);
          }
        }, 0);
      }
    });

    // Auto-resize textarea
    document.addEventListener("input", (e) => {
      if (e.target.matches(".scene-textarea")) {
        e.target.style.height = 'auto';
        e.target.style.height = e.target.scrollHeight + 'px';
      }
    });

    // Intercept submit on inline scene forms to send via fetch (no navigation)
    document.addEventListener('submit', (e) => {
      const form = e.target;
      if (!form.matches || !form.matches('.scene-form')) return;
      e.preventDefault();
      const submitBtn = form.querySelector('button[type="submit"], input[type="submit"]');
      if (submitBtn) submitBtn.disabled = true;
      submitFormWithFetch(form).catch(err => {
        console.error(err);
        if (submitBtn) submitBtn.disabled = false;
      });
    });
  })();
</script>
